By using our site, you acknowledge that you have read and understand our Cookie Policy, Privacy Policy, and our Terms of Service. Teams Q&A for Work Stack Overflow for Teams is a private, secure spot for you and
                            your coworkers to find and share information. I'm a bit confused about how Java generics handle inheritance / polymorphism. Assume the following hierarchy - Animal (Parent) Dog - Cat (Children) So suppose I have a method doSomething(List<Animal> animals). By all the rules of inheritance and polymorphism, I would assume that a List<Dog> is a List<Animal> and a List<Cat> is a List<Animal> - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying doSomething(List<? extends Animal> animals). I understand that this is Java's behavior. My question is why? Why is polymorphism generally implicit, but when it comes to generics it must be specified? No, a List<Dog> is not a List<Animal>. Consider what you can do with a List<Animal> - you can add any animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not. Suddenly you have a very confused cat. Now, you can't add a Cat to a List<? extends Animal> because you don't know it's a List<Cat>. You can retrieve a value and know that it will be an Animal, but you can't add arbitrary animals. The reverse is true for List<? super Animal> - in that case you can add an Animal to it safely, but you don't know anything about what might be retrieved from it, because it could be a List<Object>. What you are looking for is called covariant type parameters. This means that if one type of object can be substituted for another in a method (for instance, Animal can be replaced with Dog), the same applies to expressions using those objects (so List<Animal> could be replaced with List<Dog>). The problem is that covariance is not safe for mutable lists in general.  Suppose you have a List<Dog>, and it is being used as a List<Animal>.  What happens when you try to add a Cat to this List<Animal> which is really a List<Dog>?  Automatically allowing type parameters to be covariant breaks the type system. It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the ? extends Foo in method declarations, but that does add additional complexity. The reason a List<Dog> is not a List<Animal>, is that, for example, you can insert a Cat into a List<Animal>, but not into a List<Dog>... you can use wildcards to make generics more extensible where possible; for example, reading from  a List<Dog> is the similar to reading from a List<Animal> -- but not writing. The Generics in the Java Language and the Section on Generics from the Java Tutorials have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics. A point I think should be added to what other answers mention is that while List<Dog> isn't-a List<Animal> in Java it is also true that A list of dogs is-a list of animals in English (under a reasonable interpretation) The way the OP's intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds. To put it another way: A List<Dog> in Java does not mean "a list of dogs" in English, it means "a list which can have dogs, and nothing else". More generally, OP's intuition lends itself towards a language in which operations on objects can change their type, or rather, an object's type(s) is a (dynamic) function of its value. I would say the whole point of Generics is that it doesn't allow that. Consider the situation with arrays, which do allow that type of covariance: That code compiles fine, but throws a runtime error (java.lang.ArrayStoreException: java.lang.Boolean in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics. Now there are times where you need to be more flexible and that is what the ? super Class and ? extends Class are for. The former is when you need to insert into a type Collection (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type. To understand the problem it's useful to make comparison to arrays. List<Dog> is not subclass of List<Animal>.
But Dog is subclass of Animal. Arrays are reifiable and covariant. Reifiable means their type information is fully available at runtime. Therefore arrays provide runtime type safety but not compile-time type safety. It's vice versa for generics:
Generics are erased and invariant. Therefore generics can't provide runtime type safety, but they provide compile-time type safety. In the code below if generics were covariant it will be possible to make heap pollution at line 3. The answers given here didn't fully convince me. So instead, I make another example. sounds fine, doesn't it? But you can only pass Consumers and Suppliers for Animals. If you have a Mammal consumer, but a Duck supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added. Instead of the above, we have to define relationships between the types we use. E. g., makes sure that we can only use a supplier which provides us the right type of object for the consumer. OTOH, we could as well do where we go the other way: we define the type of the Supplier and restrict that it can be put into the Consumer. We even can do where, having the intuitive relations Life -> Animal -> Mammal -> Dog, Cat etc., we could even put a Mammal into a Life consumer, but not a String into a Life consumer. The basis logic for such behavior is that Generics follow a mechanism of type erasure. So at run time you have no way if identifying the type of collection unlike arrays where there is no such erasure process. So coming back to your question... So suppose there is a method as given below: Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios... Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics.... Actually you can use an interface to achieve what you want. } you can then use the collections using Subtyping is invariant for parameterized types. Even tough the class Dog is a subtype of Animal, the parameterized type List<Dog> is not a subtype of List<Animal>. In contrast, covariant subtyping is used by arrays, so the array
type Dog is a subtype of Animal. Invariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet: As stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected. It is instructive to compare the above to analogous code for arrays. The code is legal. However, throws an array store exception.
An array carries its type at run-time this way JVM can enforce
type safety of covariant subtyping. To understand this further let's look at the bytecode generated by javap of the class below: Using the command javap -c Demonstration, this shows the following Java bytecode: Observe that the translated code of method bodies are identical. Compiler replaced each parameterized type by its erasure. This property is crucial meaning that it did not break backwards compatibility. In conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar. The answer  as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down.  Even removing is OK. In most cases, we can use Collection<? extends T> rather then Collection<T> and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It is up for debate as to whether that is always the best thing to do.  I am presenting here a class DownCastCollection that can take convert a Collection<? extends T> to a Collection<T> (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use Collection<? extends Object> in this case, but I am keeping it simple to illustrate using DownCastCollection. Now the class: } If you are sure that the list items are subclasses of that given super type, you can cast the list using this approach: This is usefull when you want to pass the list inside of a constructor or iterate over it. Lets take the example from JavaSE tutorial So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation: So Java "architects" had 2 options which address this problem: do not consider that a subtype is implicitly it's supertype, and give a compile error, like it happens now consider the subtype to be it's supertype and restrict at compile the "add" method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that). For obvious reasons, that chose the first way. We should also take in consideration how the compiler threats the generic classes: in "instantiates" a different type whenever we fill the generic arguments. Thus we have ListOfAnimal, ListOfDog, ListOfCat, etc, which are distinct classes that end up being "created" by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to List is not a hierarchy at all). Another argument why covariance doesn't make sense in case of generic classes is the fact that at base all classes are the same - are List instances. Specialising a List by filling the generic argument doesn't extend the class, it just makes it work for that particular generic argument. The problem has been well-identified. But there's a solution; make doSomething generic: now you can call doSomething with either List<Dog> or List<Cat> or List<Animal>. another solution is to build a new list Further to the answer by Jon Skeet, which uses this example code: At the deepest level, the problem here is that dogs and animals share a reference. That means that one way to make this work would be to copy the entire list, which would break reference equality: After calling List<Animal> animals = new ArrayList<>(dogs);, you cannot subsequently directly assign animals to either dogs or cats: therefore you can't put the wrong subtype of Animal into the list, because there is no wrong subtype -- any object of subtype ? extends Animal can be added to animals. Obviously, this changes the semantics, since the lists animals and dogs are no longer shared, so adding to one list does not add to the other (which is exactly what you want, to avoid the problem that a Cat could be added to a list that is only supposed to contain Dog objects). Also, copying the entire list can be inefficient. However, this does solve the type equivalence problem, by breaking reference equality. To subscribe to this RSS feed, copy and paste this URL into your RSS reader. site design / logo © 2020 Stack Exchange Inc; user contributions licensed under cc by-sa.                    rev 2020.10.19.37839 