By using our site, you acknowledge that you have read and understand our Cookie Policy, Privacy Policy, and our Terms of Service. Teams Q&A for Work Stack Overflow for Teams is a private, secure spot for you and
                            your coworkers to find and share information. Please explain the following about "Cannot find symbol", "Cannot resolve symbol" or "Symbol not found" errors: This question is designed to seed a comprehensive Q&A about these common compilation errors in Java. Not really. "Cannot find symbol", "Cannot resolve symbol" and "Symbol not found" all mean the same thing.  Different Java compilers use different phraseology. Firstly, it is a compilation error1.  It means that either there is a problem in your Java source code, or there is a problem in the way that you are compiling it. Your Java source code consists of the following things: A "Cannot find symbol" error is about the identifiers.  When your code is compiled, the compiler needs to work out what each and every identifier in your code means. A "Cannot find symbol" error means that the compiler cannot do this.  Your code appears to be referring to something that the compiler doesn't understand. As a first order, there is only one cause.  The compiler looked in all of the places where the identifier should be defined, and it couldn't find the definition.  This could be caused by a number of things.  The common ones are as follows: For identifiers in general: For identifiers that should refer to variables: For identifiers that should be method or field names: Perhaps you are trying to refer to an inherited method or field that wasn't declared in the parent / ancestor classes or interfaces. Perhaps you are trying to refer to a method or field that does not exist (i.e. has not been declared) in the type you are using; e.g. "someString".push()2. Perhaps you are trying to use a method as a field, or vice versa; e.g. "someString".length or someArray.length(). Perhaps you are mistakenly operating on an array rather than array element; e.g. For identifiers that should be class names: Perhaps you forgot to import the class. Perhaps you used "star" imports, but the class isn't defined in any of the packages that you imported. Perhaps you forgot a new as in: For cases where type or instance doesn't appear to have the member you were expecting it to have: The problem is often a combination of the above.  For example, maybe you "star" imported java.io.* and then tried to use the Files class ... which is in java.nio not java.io.  Or maybe you meant to write File ... which is a class in java.io. Here is an example of how incorrect variable scoping can lead to a "Cannot find symbol" error: This will give a "Cannot find symbol" error for i in the if statement.  Though we previously declared i, that declaration is only in scope for the for statement and its body.  The reference to i in the if statement cannot see that declaration of i.  It is out of scope. (An appropriate correction here might be to move the if statement inside the loop, or to declare i before the start of the loop.) Here is an example that causes puzzlement where a typo leads to a seemingly inexplicable "Cannot find symbol" error: This will give you a compilation error in the println call saying that i cannot be found.  But (I hear you say) I did declare it! The problem is the sneaky semicolon ( ; ) before the {.  The Java language syntax defines a semicolon in that context to be an empty statement.  The empty statement then becomes the body of the for loop.  So that code actually means this: The { ... } block is NOT the body of the for loop, and therefore the previous declaration of i in the for statement is out of scope in the block. Here is another example of "Cannot find symbol" error that is caused by a typo. Despite the previous declaration, the tmp in the tmp(...) expression is erroneous.  The compiler will look for a method called tmp, and won't find one.  The previously declared tmp is in the namespace for variables, not the namespace for methods. In the example I came across, the programmer had actually left out an operator.  What he meant to write was this: There is another reason why the compiler might not find a symbol if you are compiling from the command line.  You might simply have forgotten to compile or recompile some other class.  For example, if you have classes Foo and Bar where Foo uses Bar.  If you have never compiled Bar and you run javac Foo.java, you are liable to find that the compiler can't find the symbol Bar.  The simple answer is to compile Foo and Bar together; e.g. javac Foo.java Bar.java or javac *.java.  Or better still use a Java build tool; e.g. Ant, Maven, Gradle and so on. There are some other more obscure causes too ... which I will deal with below. Generally speaking, you start out by figuring out what caused the compilation error. Then you think about what your code is supposed to be saying.  Then finally you work out what correction you need to make to your source code to do what you want. Note that not every "correction" is correct. Consider this: Suppose that the compiler says "Cannot find symbol" for j.  There are many ways I could "fix" that: The point is that you need to understand what your code is trying to do in order to find the right fix. Here are a couple of cases where the "Cannot find symbol" is seemingly inexplicable ... until you look closer. Incorrect dependencies: If you are using an IDE or a build tool that manages the build path and project dependencies, you may have made a mistake with the dependencies; e.g. left out a dependency, or selected the wrong version.  If you are using a build tool (Ant, Maven, Gradle, etc), check the project's build file.  If you are using an IDE, check the project's build path configuration. You are not recompiling:  It sometimes happens that new Java programmers don't understand how the Java tool chain works, or haven't implemented a repeatable "build process"; e.g. using an IDE, Ant, Maven, Gradle and so on.  In such a situation, the programmer can end up chasing his tail looking for an illusory error that is actually caused by not recompiling the code properly, and the like ... An earlier build problem:  It is possible that an earlier build failed in a way that gave a JAR file with missing classes.  Such a failure would typically be noticed if you were using a build tool.  However if you are getting JAR files from someone else, you are dependent on them building properly, and noticing errors.  If you suspect this, use tar -tvf to list the contents of the suspect JAR file. IDE issues: People have reported cases where their IDE gets confused and the compiler in the IDE cannot find a class that exists ... or the reverse situation. This could happen if the IDE has been configured with the wrong JDK version. This could happen if the IDE's caches get out of sync with the file system.  There are IDE specific ways to fix that. This could be an IDE bug.  For instance @Joel Costigliola describes a scenario where Eclipse does not handle a Maven "test" tree correctly: see this answer. Android issues: When you are programming for Android, and you have "Cannot find symbol" errors related to R, be aware that the R symbols are defined by the context.xml file.  Check that your context.xml file is correct and in the correct place, and that the corresponding R class file has been generated / compiled.  Note that the Java symbols are case sensitive, so the corresponding XML ids are be case sensitive too. Other symbol errors on Android are likely to be due to previously mention reasons; e.g. missing or incorrect dependencies, incorrect package names, method or fields that don't exist in a particular API version, spelling / typing errors, and so on. Redefining system classes: I've seen cases where the compiler complains that substring is an unknown symbol in something like the following It turned out that the programmer had created their own version of String and that his version of the class didn't define a substring methods. Lesson: Don't define your own classes with the same names as common library classes! Homoglyphs:  If you use UTF-8 encoding for your source files, it is possible to have identifiers that look the same, but are in fact different because they contain homoglyphs.   See this page for more information. You can avoid this by restricting yourself to ASCII or Latin-1 as the source file encoding, and using Java \uxxxx escapes for other characters. 1 - If, perchance, you do see this in a runtime exception or error message, then either you have configured your IDE to run code with compilation errors, or your application is generating and compiling code .. at runtime. 2 - The three basic principles of Civil Engineering: water doesn't flow uphill, a plank is stronger on its side, and you can't push on a string. You'll also get this error if you forget a new: versus because the call without the new keyword will try and look for a (local) method called String without arguments - and that method signature is likely not defined. One more example of 'Variable is out of scope' As I've seen that kind of questions a few times already, maybe one more example to what's illegal even if it might feel okay. Consider this code: That's invalid code. Because neither of the variables named message is visible outside of their respective scope - which would be the surrounding brackets {} in this case. You might say: "But a variable named message is defined either way - so message is defined after the if". But you'd be wrong. Java has no free() or delete operators, so it has to rely on tracking variable scope to find out when variables are no longer used (together with references to these variables of cause). It's especially bad if you thought you did something good. I've seen this kind of error after "optimizing" code like this: "Oh, there's duplicated code, let's pull that common line out" -> and there it it. The  most common way to deal with this kind of scope-trouble would be to pre-assign the else-values to the variable names in the outside scope and then reassign in if: One way to get this error in Eclipse : Result : Eclipse will compile the code, but maven will give "Cannot find symbol". Underlying cause : Eclipse is using a combined build path for the main and test trees.  Unfortunately, it does not support using different build paths for different parts of an Eclipse project, which is what Maven requires. Solution : "Can not find " means that , compiler who can't find appropriate variable, method ,class etc...if you got that error massage , first of all you want to find code line where get error massage..And then you will able to find which variable , method or class have not define before using it.After confirmation  initialize that variable ,method or class can be used for later require...Consider the following example. I'll create a demo class and print a name... Now look at the result..  That error says, "variable name can not find"..Defining and initializing value for 'name' variable  can be abolished that error..Actually like this, Now look at the new output...  Ok Successfully solved that error..At the same time , if you could get "can not find method " or "can not find class" something , At first,define a class or method and after use that.. If you're getting this error in the build somewhere else, while your IDE says everything is perfectly fine, then check that you are using the same Java versions in both places. For example, Java 7 and Java 8 have different APIs, so calling a non-existent API in an older Java version would cause this error. I too was getting this error. (for which I googled and I was directed to this page) Problem: I was calling a static method defined in the class of a project A from a class defined in another project B. 
I was getting the following error: Solution: I resolved this by first building the project where the method is defined then the project where the method was being called from. If eclipse Java build path is mapped to 7, 8 and in Project pom.xml Maven properties java.version is mentioned higher Java version(9,10,11, etc..,) than 7,8 you need to update in pom.xml file. In Eclipse if Java is mapped to Java version 11 and in pom.xml it is mapped to Java version 8. Update Eclipse support to Java 11 by go through below steps in eclipse IDE
Help -> Install New Software -> Paste following link http://download.eclipse.org/eclipse/updates/4.9-P-builds at Work With or Add (Popup window will open) -> Name: Java 11 support
Location: http://download.eclipse.org/eclipse/updates/4.9-P-builds then update Java version in Maven properties of pom.xml file as below Finally do right click on project Debug as -> Maven clean, Maven build steps SOLVED Using IntelliJ Select Build->Rebuild Project will solve it There can be various scenarios as people have mentioned above. A couple of things which have helped me resolve this. If you are using IntelliJ File -> 'Invalidate Caches/Restart' OR The class being referenced was in another project and that dependency was not added to the Gradle build file of my project. So I added the dependency using compile project(':anotherProject') and it worked. HTH! you compiled your code using maven compile and then used maven test to run it worked fine. Now if you changed something in your code and then without compiling you are running it, you will get this error. Solution: Again compile it and then run test. For me it worked this way. In my case - I had to perform below operations: For hints, look closer at the class name name that throws an error and the line number, example:
Compilation failure
 \applications\xxxxx.java: error: cannot find symbol One other cause is unsupported method of for java version say jdk7 vs 8.
Check your %JAVA_HOME% We got the error in a Java project that is set up as a Gradle multi-project build. It turned out that one of the sub-projects was missing the Gradle Java Library plugin.
This prevented the sub-project's class files from being visible to other projects in the build. After adding the Java library plugin to the sub-project's build.gradle in the following way, the error went away: To subscribe to this RSS feed, copy and paste this URL into your RSS reader. site design / logo © 2020 Stack Exchange Inc; user contributions licensed under cc by-sa.                    rev 2020.10.19.37839 