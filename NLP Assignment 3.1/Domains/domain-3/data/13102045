By using our site, you acknowledge that you have read and understand our Cookie Policy, Privacy Policy, and our Terms of Service. Teams Q&A for Work Stack Overflow for Teams is a private, secure spot for you and
                            your coworkers to find and share information. I am using the Scanner methods nextInt() and nextLine() for reading input. It looks like this: The problem is that after entering the numerical value, the first input.nextLine() is skipped and the second input.nextLine() is executed, so that my output looks like this: I tested my application and it looks like the problem lies in using input.nextInt(). If I delete it, then both string1 = input.nextLine() and string2 = input.nextLine() are executed as I want them to be. That's because the Scanner.nextInt method does not read the newline character in your input created by hitting "Enter," and so the call to Scanner.nextLine returns after reading that newline. You will encounter the similar behaviour when you use Scanner.nextLine after Scanner.next() or any Scanner.nextFoo method (except nextLine itself). Workaround: Either put a Scanner.nextLine call after each Scanner.nextInt or Scanner.nextFoo to consume rest of that line including newline Or, even better, read the input through Scanner.nextLine and convert your input to the proper format you need. For example, you may convert to an integer using Integer.parseInt(String) method. The problem is with the input.nextInt() method - it only reads the int value. So when you continue reading with input.nextLine() you receive the "\n" Enter key. So to skip this you have to add the input.nextLine(). Hope this should be clear now. Try it like that: It's because when you enter a number then press Enter, input.nextInt() consumes only the number, not the "end of line". When input.nextLine() executes, it consumes the "end of line" still in the buffer from the first input. Instead, use input.nextLine() immediately after input.nextInt() There seem to be many questions about this issue with java.util.Scanner. I think a more readable/idiomatic solution would be to call scanner.skip("+") to drop any newline characters after calling nextInt(). EDIT: as @PatrickParker noted below, this will cause an infinite loop if user inputs any whitespace after the number. See their answer for a better pattern to use with skip: https://stackoverflow.com/a/42471816/143585 It does that because input.nextInt(); doesn't capture the newline. you could do like the others proposed by adding an input.nextLine(); underneath.
Alternatively you can do it C# style and parse a nextLine to an integer like so: Doing this works just as well, and it saves you a line of code. TL;DR Use scanner.skip("\\R") before each scanner.newLine() call, which is executed after: text which represents few lines also contains non-printable characters between lines (we call them line separators) like carriage return (CR - in String literals represented as "\r") line feed (LF - in String literals represented as "\n") when you are reading data from the console, it allows the user to type his response and when he is done he needs to somehow confirm that fact. To do so, the user is required to press "enter"/"return" key on the keyboard. What is important is that this key beside ensuring placing user data to standard input (represented by System.in which is read by Scanner) also sends OS dependant line separators (like for Windows \r\n) after it. So when you are asking the user for value like age, and user types 42 and presses enter, standard input will contain "42\r\n". Scanner#nextInt (and other Scanner#nextType methods) doesn't allow Scanner to consume these line separators. It will read them from System.in (how else Scanner would know that there are no more digits from the user which represent age value than facing whitespace?) which will remove them from standard input, but it will also cache those line separators internally. What we need to remember, is that all of the Scanner methods are always scanning starting from the cached text. Now Scanner#nextLine() simply collects and returns all characters until it finds line separators (or end of stream). But since line separators after reading the number from the console are found immediately in Scanner's cache, it returns empty String, meaning that Scanner was not able to find any character before those line separators (or end of stream).
BTW nextLine also consumes those line separators. So when you want to ask for number and then for entire line while avoiding that empty string as result of nextLine, either BTW: Scanner#nextType methods can skip delimiters (by default all whitespaces like tabs, line separators) including those cached by scanner, until they will find next non-delimiter value (token). Thanks to that for input like "42\r\n\r\n321\r\n\r\n\r\nfoobar" code will be able to properly assign num1=42 num2=321 name=foobar. Instead of input.nextLine() use input.next(), that should solve the problem. Modified code: If you want to read both strings and ints, a solution is to use two Scanners: If you want to scan input fast without getting confused into Scanner class nextLine() method , Use Custom Input Scanner for it . ScanReader sc = new ScanReader(System.in);

3. Import necessary Classes : import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
 
4. Throw IOException from your main method to handle Exception
5. Use Provided Methods.
6. Enjoy In order to avoid the issue, use nextLine(); immediately after nextInt(); as it helps in clearing out the buffer. When you press ENTER the nextInt(); does not capture the new line and hence, skips the Scanner code later. sc.nextLine() is better as compared to parsing the input.
Because performance wise it will be good. I guess I'm pretty late to the party.. As previously stated, calling input.nextLine() after getting your int value will solve your problem. The reason why your code didn't work was because there was nothing else to store from your input (where you inputted the int) into string1. I'll just shed a little more light to the entire topic. Consider nextLine() as the odd one out among the nextFoo() methods in the Scanner class. Let's take a quick example.. Let's say we have two lines of code like the ones below: If we input the value below (as a single line of input) 54 234 The value of our firstNumber and secondNumber variable become 54 and 234 respectively. The reason why this works this way is because a new line feed (i.e \n)  IS NOT automatically generated when the nextInt() method takes in the values. It simply takes the "next int" and moves on. This is the same for the rest of the nextFoo() methods except nextLine(). nextLine() generates a new line feed immediately after taking a value; this is what @RohitJain means by saying the new line feed is "consumed". Lastly, the next() method simply takes the nearest String without generating a new line; this makes this the preferential method for taking separate Strings within the same single line. I hope this helps.. Merry coding! Use 2 scanner objects instead of one if I expect a non-empty input used in above example: In one of my usecase, I had the scenario of reading a string value preceded by a couple of integer values. I had to use a "for / while loop" to read the values. And none of the above suggestions worked in this case. Using input.next() instead of input.nextLine() fixed the issue. Hope this might be helpful for those dealing with similar scenario. Use this code it will fix your problem. As nextXXX() methods don't read newline, except nextLine(). We can skip the newline after reading any non-string value (int in this case) by using scanner.skip() as below: Why not use a new Scanner for every reading? Like below. With this approach you will not confront your problem. To subscribe to this RSS feed, copy and paste this URL into your RSS reader. site design / logo © 2020 Stack Exchange Inc; user contributions licensed under cc by-sa.                    rev 2020.10.19.37839 