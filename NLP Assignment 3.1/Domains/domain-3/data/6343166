By using our site, you acknowledge that you have read and understand our Cookie Policy, Privacy Policy, and our Terms of Service. Teams Q&A for Work Stack Overflow for Teams is a private, secure spot for you and
                            your coworkers to find and share information. I got an error while running my Android project for RssReader. Code: And it shows the below error: How can I fix this issue? NOTE : AsyncTask was deprecated in API level 30.
https://developer.android.com/reference/android/os/AsyncTask This exception is thrown when an application attempts to perform a networking operation on its main thread. Run your code in AsyncTask: How to execute the task: In MainActivity.java file you can add this line within your oncreate() method Don't forget to add this to AndroidManifest.xml file: You should almost always run network operations on a thread or as an asynchronous task. But it is possible to remove this restriction and you override the default behavior, if you are willing to accept the consequences. Add: In your class, and ADD this permission in android manifest.xml file: Consequences: Your app will (in areas of spotty internet connection) become unresponsive and lock up, the user perceives slowness and has to do a force kill, and you risk the activity manager killing your app and telling the user that the app has stopped. Android has some good tips on good programming practices to design for responsiveness:
http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html I solved this problem using a new Thread. The accepted answer has some significant down-sides. It is not advisable to use AsyncTask for networking unless you really know what you are doing. Some of the down-sides include: If you want to avoid short-term memory leaks, have well-defined execution characteristics across all platforms, and have a base to build really robust network handling, you might want to consider: Down-sides: Up-sides: You can implement an IntentService to perform downloads on a single background thread quite easily. Step 1: Create an IntentService to perform the download. You can tell it what to download via Intent extra's, and pass it a PendingIntent to use to return the result to the Activity: Step 2: Register the service in the manifest: Step 3: Invoke the service from the Activity, passing a PendingResult object which the Service will use to return the result: Step 4: Handle the result in onActivityResult: A Github project containing a complete working Android-Studio/Gradle project is available here. You cannot perform network I/O on the UI thread on Honeycomb. Technically, it is possible on earlier versions of Android, but it is a really bad idea as it will cause your app to stop responding, and can result in the OS killing your app for being badly behaved. You'll need to run a background process or use AsyncTask to perform your network transaction on a background thread. There is an article about Painless Threading on the Android developer site which is a good introduction to this, and it will provide you with a much better depth of an answer than can be realistically provided here. Do the network actions on another thread For Example: And add this to AndroidManifest.xml Use Service or AsyncTask See also Stack Overflow question: android.os.NetworkOnMainThreadException sending an email from Android You disable the strict mode using following code: This is not recommended: use the AsyncTask interface. Full code for both the methods Network-based operations cannot be run on the main thread. You need to run all network-based tasks on a child thread or implement AsyncTask. This is how you run a task in a child thread: Put your code inside: Or: This happens in Android 3.0 and above. From Android 3.0 and above, they have restricted using network operations (functions that access the Internet) from running in the main thread/UI thread (what spawns from your on create and on resume methods in the activity). This is to encourage using separate threads for network operations. See AsyncTask for more details on how to perform network activities the right way. Using Android Annotations is an option. It will allow you to simply run any method in a background thread: Note, that although it provides benefits of simplicity and readability, it has its disadvantages. The error is due to executing long running operations in main thread,You can easily rectify the problem by using AsynTask or Thread. You can checkout this library AsyncHTTPClient for better handling. You should not do any time-consuming task on the main thread (UI thread), like any network operation, file I/O, or SQLite database operations. So for this kind of operation, you should create a worker thread, but the problem is that you can not directly perform any UI related operation from your worker thread. For that, you have to use Handler and pass the Message. To simplify all these things, Android provides various ways, like AsyncTask, AsyncTaskLoader, CursorLoader or IntentService. So you can use any of these according to your requirements. The top answer of spektom works perfect. If you are writing the AsyncTask inline and not extending as a class, and on top of this, if there is a need to get a response out of the AsyncTask, one can use the get() method as below. (From his example.) This is only thrown for applications targeting the Honeycomb SDK or higher. Applications targeting earlier SDK versions are allowed to do networking on their main event loop threads. The error is the SDK warning! For me it was this: The device I was testing my app on was 4.1.2 which is SDK Version 16! Make the sure the target version is the same as your Android Target Library. If you are unsure what your target library is, right click your Project -> Build Path -> Android, and it should be the one that is ticked. Also, as others have mentioned, include the correct permissions to access the Internet: Use this in Your Activity Just to spell out something explicitly: The main thread is basically the UI thread. So saying that you cannot do networking operations in the main thread means you cannot do networking operations in the UI thread, which means you cannot do networking operations in a *runOnUiThread(new Runnable() { ... }* block inside some other thread, either. (I just had a long head-scratching moment trying to figure out why I was getting that error somewhere other than my main thread.  This was why; this thread helped; and hopefully this comment will help someone else.) This exception occurs due to any heavy task performed on the main thread if that performing task takes too much time. To avoid this, we can handle it using threads or executers There are many great answers already on this question, but a lot of great libraries have come out since those answers were posted. This is intended as a kind of newbie-guide. I will cover several use cases for performing network operations and a solution or two for each. Typically Json, can be XML or something else Let's say you are writing an app that lets users track stock prices, interest rates and currecy exchange rates. You find an Json API that looks something like this: This is an excellent choice for an API with multiple endpoints and allows you to declare the ReST endpoints instead of having to code them individually as with other libraries like ion or Volley. (website: http://square.github.io/retrofit/) How do you use it with the finances API? build.gradle Add these lines to your Module level buid.gradle: FinancesApi.java FinancesApiBuilder FinancesFragment snippet If your API requires an API Key or other header like a user token, etc. to be sent, Retrofit makes this easy (see this awesome answer for details: https://stackoverflow.com/a/42899766/1024412). Let's say you're building a "mood weather" app that looks up the users GPS location and checks the current temperature in that area and tells them the mood. This type of app doesn't need to declare API endpoints; it just needs to be able to access one API endpoint. This is a great library for this type of access. Please read msysmilu's great answer (https://stackoverflow.com/a/28559884/1024412) Volley can also be used for ReST APIs, but due to the more complicated setup required I prefer to use Retrofit from Square as above (http://square.github.io/retrofit/) Let's say you are building a social networking app and want to load profile pictures of friends. build.gradle Add this line to your Module level buid.gradle: ImageFetch.java Volley requires more setup than Retrofit. You will need to create a class like this to setup a RequestQueue, an ImageLoader and an ImageCache, but it's not too bad: user_view_dialog.xml Add the following to your layout xml file to add an image: UserViewDialog.java Add the following code to the onCreate method (Fragment, Activity) or the constructor (Dialog): Another excellent library from Square. Please see the site for some great examples: http://square.github.io/picasso/ In simple words, DO NOT DO NETWORK WORK IN THE UI THREAD For example, if you do an HTTP request, that is a network action. Solution: Way: Put all your works inside But: When you get something from Network response and want to show it on your view (like display response message in TextView), you need to return back to the UI thread. If you don't do it, you will get ViewRootImpl$CalledFromWrongThreadException. How to? You are able to move a part of your code into another thread to offload the main thread and avoid getting ANR, NetworkOnMainThreadException, IllegalStateException(e.g. Cannot access database on the main thread since it may potentially lock the UI for a long period of time). There are some approaches that you should choose depends on the situation Java Thread or Android HandlerThread Java threads are one-time use only and die after executing its run method. HandlerThread is a handy class for starting a new thread that has a looper. AsyncTask AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as Executor, ThreadPoolExecutor and FutureTask. Since Main thread monopolizes UI components it is not possible to access to some View, that is why Handler is on the rescue Thread pool implementation ThreadPoolExecutor, ScheduledThreadPoolExecutor... ThreadPoolExecutor class that implements ExecutorService which gives fine control on the thread pool (Eg, core pool size, max pool size, keep alive time, etc.) ScheduledThreadPoolExecutor - a class that extends ThreadPoolExecutor. It can schedule tasks after a given delay or periodically. FutureTask FutureTask performs asynchronous processing, however, if the result is not ready yet or processing has not complete, calling get() will be block the thread AsyncTaskLoaders AsyncTaskLoaders as they solve a lot of problems that are inherent to AsyncTask IntentService This is the defacto choice for long running processing on Android, a good example would be to upload or download large files. The upload and download may continue even if the user exits the app and you certainly do not want to block the user from being able to use the app while these tasks are going on. JobScheduler Effectively, you have to create a Service and create a job using JobInfo.Builder that specifies your criteria for when to run the service. RxJava Library for composing asynchronous and event-based programs by using observable sequences. Coroutines (Kotlin) The main gist of it is, it makes asynchronous code looks so much like synchronous Read more here, here, here, here New Thread and AsyncTask solutions have been explained already. AsyncTask should ideally be used for short operations. Normal Thread is not preferable for Android. Have a look at alternate solution using HandlerThread and Handler HandlerThread Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called. Handler: A Handler allows you to send and process Message and Runnable objects associated with a thread's MessageQueue. Each Handler instance is associated with a single thread and that thread's message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it -- from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue. Solution: Create HandlerThread Call start() on HandlerThread Create Handler by getting Looper from HanlerThread Embed your Network operation related code in Runnable object Submit Runnable task to Handler Sample code snippet, which address  NetworkOnMainThreadException Pros of using this approach: Although above there is a huge solution pool, no one mentioned com.koushikdutta.ion: https://github.com/koush/ion It's also asynchronous and very simple to use: There is another very convenient way for tackling this issue - use rxJava's concurrency capabilities. You can execute any task in background and post results to main thread in a very convenient way, so these results will be handed to processing chain. The first verified answer advice is to use AsynTask. Yes, this is a solution, but it is obsolete nowadays, because there are new tools around. The getUrl method provides the URL address, and it will be executed on the main thread. makeCallParseResponse(..) - does actual work processResponse(..) - will handle result on main thread. The code for asynchronous execution will look like: Compared to AsyncTask, this method allow to switch schedulers an arbitrary number of times (say, fetch data on one scheduler and process those data on another (say, Scheduler.computation()). You can also define you own schedulers. In order to use this library, include following lines into you build.gradle file: The last dependency includes support for the .mainThread() scheduler. There is an excellent ebook for rx-java. RxAndroid is another better alternative to this problem and it saves us from hassles of creating threads and then posting results on Android UI thread.
We just need to specify threads on which tasks need to be executed and everything is handled internally. By specifiying (Schedulers.io()),RxAndroid will run getFavoriteMusicShows()  on a different thread. By using AndroidSchedulers.mainThread() we want to observe this Observable on the UI thread, i.e. we want our onNext() callback to be called on the UI thread The main thread is the UI thread, and you cannot do an operation in the main thread which may block the user interaction. You can solve this in two ways: Force to do the task in the main thread like this Or create a simple handler and update the main thread if you want. And to stop the thread use: For more information check this out: Painless threading This works. Just made Dr.Luiji's answer a little simpler. On Android, network operations cannot be run on the main thread. You can use Thread, AsyncTask (short-running tasks), Service (long-running tasks) to do network operations. To subscribe to this RSS feed, copy and paste this URL into your RSS reader. site design / logo © 2020 Stack Exchange Inc; user contributions licensed under cc by-sa.                    rev 2020.10.19.37839 